# Object Oriented Design

Shaping the analysis model into a detailed design model

`blueprint` for constructing software

These is achieved through two levels of modularity.

## levels of modularity

1. **Subsystem partitioning** - organizing a system into subsystems

- providing a structured and organized approach to managing the complexity of software

2. **Encapsulation** -- organizing the objects and features

- creating boxes for each task making everything easier to handle and undestand

## Aspects of object oriented design
1. **Data Organization of Attributes**

How data attributes are organized within the objects

The type of data each object will hold

How the data is related to one another

`Ensures a coherent and efficient data structure`

2. **Procedural Description of Operations**

detailed steps or processes involved in carrying out specific tasks

`Ensures clarity and presicion in the implementation of functionality`

# Pyramid for Object-oriented Systems

1. **Subsystems Design**

organize classes into larger, integrated units 

`enables software to achieve user requirements and implement technical frameworks that meet user needs.`

2. **Class and Object Layer** 

structure and behaviour of individual classes and objects

`class hierarchies that enable the system to develop using generalization and specialization`

*represents each object*

3. **Message Layer**

specifies communication between objects

`how objects interact with each other`

- method calls
- messages between objects
- flow of control within the system

4. **Responsibility Layer**

Responsibilities of individual objects

`behavious assigned to each class or object in the system`

- behaviour of each class
- what an object is responsible for
- how it responds to messages

## Advantages
1. **Improved modularity** -- small reuseable objects combined to create more complex systems.

`improves the modularity and maintainability of software`

2. **Better abstraction** -- easier to understand and maintain
3. **Improved reuse** --reduces the amount of code that needs to be written 

`improves the quality and consistency of the software`

4. **Improved communication** -- common vocabulary and methodology for software development

`improves communication and collaboration within teams`

5. **Reusability** -- saves time and effort in software development

`reduces the need to create new code from scratch`

6. **Scalability** -- handle changes in user demand and business needs over time
7. **Maintainability** -- easier to maintain and update
8. **Flexibility** -- adapt to changing requirements
9. **Improved quality** -- emphasize use of encapsulation, inheritance and polymorphism

`leads to software systems that are reliable, secure and efficient`

## Disadvantage

1. **Complexity** needs careful modeling and management
2. **Overhead** objects need instantiation, management and interactions which `slows doen the performance of software`
3. **steep learning curve** needs understanding of `OOP concepts and techniques`
4. **time consuming** longer development time because of upfront planning and documentation
5. **Rigidity** do not work well with `rapidly developing environments` 
6. **cost** planning and documenting is expensive

